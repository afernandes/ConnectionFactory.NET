{"name":"ConnectionFactory.NET","tagline":"Connection Factory","body":"Framework Connection Factory\r\n===================\r\n\r\n[TOC]\r\n\r\n##Objetivo\r\nOferecer um conjunto de funções para comunicação com banco de dados auxiliando no trabalho dos desenvolvedores de sistemas.\r\n\r\n## Premissas\r\nimplementar funções similares ao iBATIS DAO que simplificando a camada de persistência com o banco de dados, mas **não utilizar os XML de mapeamento**. \r\n\r\n##Características\r\n\r\nSuporte a todos provedores de bancos de dados que implementam o ADO.NET\r\n: Tudo que é necessário para para se conectar a um novo banco é adicioná-lo ao arquivo de configurações  ([exemplo do Web.config](#web.config))\r\n[Bancos de dados suportados (SQl Server, Oracle, MySQL, etc)](https://msdn.microsoft.com/pt-br/library/dd363565.aspx)\r\n\r\nConexão simplificada\r\n: Conecta ao banco passando apenas o nome da conexão gravado no arquivo de configurações. ([exemplo](#conectando))\r\n\r\nTransação entre servidores / bancos de dados\r\n: Transações entre múltiplas conexões independente se estão em bancos de dados ou servidores diferentes ([exemplo](#transactionScope))\r\n\r\nRetorno automático de entidades (DTO / VO) carregadas a partir das querys\r\n: Executa as querys e carrega as entidades automaticamente evitando linhas repetitivas de codigo para carregar cada membro do objeto. ([exemplo](#AutoLoadEntities))\r\n\r\n##Pré-requisito\r\n\r\n###Coordenador de Transações Distribuídas (MSDTC)\r\n\r\n>MSDTC - Microsoft Distributed Transaction Coordinator \r\n\r\n#### O que faz o Coordenador de Transações Distribuídas?\r\nO serviço DTC (Coordenador de Transações Distribuídas) coordena as transações que atualizam dois ou mais recursos protegidos por transação, como bancos de dados, filas de mensagens, sistemas de arquivos, entre outros. Esses recursos protegidos por transação podem estar em um único computador ou distribuídos em vários computadores em rede.\r\n\r\n#### Configurando o serviço do MSDTC\r\n\r\nAtivar o MSDTC\r\n: Certifique-se de que o MSDTC está habilitado em ambos os servidores de banco de dados.\r\n\r\n\t- Em caso de aplicações Web, também deve estar ativo no servidor IIS\r\n\t- Em caso de aplicações Desktop, tambem deve estar ativo nas maquinas cliente que rodam o aplicativo.\r\n\t- Em todos os casos também deve estar ativo no computador dos desenvolvedores para possibilitar o debug das `TransactionScope`\r\n\r\n1. **Ativar o Serviço do MSDTC**\r\n\t1. Vá em Iniciar -> Executar -> digite: \"**Services.msc**\"\r\n\t2. Ative o serviço: Coordenador de Transações Distribuídas\r\n\r\n2. **Configurar o MSDTC**\r\n\t1. Vá em Iniciar -> Painel de Controle -> Ferramentas Administrativas -> **Serviços de Componentes** \r\n\t\t1. Ou Executar: **%windir%\\system32\\comexp.msc**\r\n\t\t2. Ou Executar: **dcomcnfg.exe**\r\n\r\n3. **Navegue até...**\r\n\t1. **No Windows 7**\r\n\tExpanda Raiz do console **->** Serviços de componente **->** Computadores **->** Meu computador **->** Coordenador de Transações Distribuídas **->** Local DTC\r\n\t\t**Propriedades do Botão direito do mouse**\r\n\r\n 2. **No Windows XP**\r\n Expanda Raiz do console **->** Serviços de componente **->** Computadores **->** Meu computador \r\n**Propriedades do Botão direito do mouse**\r\n\r\n4. **Permitir acesso ao DTC de Rede**\r\nVá na aba segurança e marque as opções \r\n- [x] **Acesso DTC de Rede**\r\n- [x] **Permitir Entrada**\r\n- [x] **Permitir Saída**\r\n- [x] **Nenhuma Autenticação Necessária**\r\n\r\n\t**Clique em Ok e Reinicie o computador**\r\n\t[![](https://suneethasdiary.files.wordpress.com/2011/05/msdtc-settings2.jpg?w=274&h=300)](https://suneethasdiary.files.wordpress.com/2011/05/msdtc-settings2.jpg)\r\n\r\n#### Checar se MSDTC está ativo no banco de dados\r\n\r\n```sql\r\nUSE master\r\nEXEC xp_servicecontrol N'querystate',N'msdtc'\r\n```\r\n\r\n#### Exemplo C# de uso do MSDTC\r\n\r\n##### **Exemplo sem utilizar a Connection Factory**\r\n```cs\r\nusing System.Transactions;\r\n\r\nusing (TransactionScope txSc = new TransactionScope())\r\n{\r\n\t//Conexão com o primeiro banco de dados\r\n\tusing (SqlConnection cn = new SqlConnection(connStr1))\r\n    {\r\n\t\tSqlCommand cmd = cn.CreateCommand();\r\n\t\tcmd.CommandText = \"Insert into Demo(DemoValue)  Values ('XXX')\";\r\n\t\tcn.Open();\r\n\t\tcmd.ExecuteNonQuery();\r\n\t\tcn.Close();\r\n\t}\r\n\r\n\t//Conexão com o segundo banco de dados\r\n\tusing (SqlConnection cn = new SqlConnection(connStr))\r\n    {\r\n\t\tSqlCommand cmd = cn.CreateCommand();\r\n\t\tcmd.CommandText = \"Insert into Demo(DemoValue) Values ('YYY')\";\r\n\t\tcn.Open();\r\n\t\tcmd.ExecuteNonQuery();\r\n\t\tcn.Close();\r\n\t}\r\n\r\n\tConsole.WriteLine( \"Transaction identifier:\" +\r\n\t\tTransaction.Current.TransactionInformation.\r\n\t\tDistributedIdentifier);\r\n    \r\n    //Commit nas duas conexões dentro do escopo da transação\r\n    txSc.Complete();\r\n}\r\n```\r\n\r\n##### **Exemplo utilizando a Connection Factory**\r\n\r\nExemplo de uso da `TransactionScope` dentro da Camada **BO**\r\n\r\n```cs\r\npublic Int32 InsertOrUpdate(Vo.User user)\r\n{\r\n   Logger.Debug(\"Begin Method\");\r\n   int result = -1;\r\n\r\n   try\r\n   {\r\n      // limit transaction scope\r\n      using (var scope = new TransactionScope())\r\n      {\r\n         // call the UserDAO to save User in DB\r\n         var userDAO = new UserDAO();\r\n         result = userDAO.SaveOrUpdate(user);\r\n\r\n         // delete all dependecies before insert/update new ones\r\n         userDAO.DeleteUserDependencies(result);\r\n\r\n         // profile list relationship\r\n         if (user.ProfileList != null && user.ProfileList.Count > 0)\r\n         {\r\n            foreach (var profileUser in user.ProfileList)\r\n            {\r\n               if (profileUser != null)\r\n               {\r\n                  userDAO.InsertUserProfile(result, profileUser.Id);\r\n               }\r\n            }\r\n         }\r\n\r\n         // role list\r\n         if (user.RolesList != null && user.RolesList.Count > 0)\r\n         {\r\n            foreach (var role in user.RolesList)\r\n            {\r\n               if (role != null)\r\n               {\r\n                  userDAO.InsertRole(result, role.Id);\r\n               }\r\n            }\r\n         }\r\n\r\n\r\n         scope.Complete();\r\n      }\r\n   }\r\n   catch (TransactionAbortedException tae)\r\n   {\r\n      Logger.Error(tae);\r\n      throw new BusinessException(\"Error on persistence layer\", tae);\r\n   }\r\n   catch (LockException lockex)\r\n   {\r\n      Logger.Error(lockex);\r\n      throw new LockException(\"Lock Exception\", lockex);\r\n   }\r\n   catch (PersistenceException pex)\r\n   {\r\n      Logger.Error(pex);\r\n      throw new BusinessException(\"Error on persistence layer\", pex);\r\n   }\r\n   catch (Exception ex)\r\n   {\r\n      Logger.Error(ex);\r\n      throw new BusinessException(\"An unexpected error has occured while handling business layer info.\", ex);\r\n   }\r\n\r\n   Logger.Debug(\"End Method\");\r\n\r\n   return result;\r\n}\r\n```\r\n\r\n\r\n### <a id=\"web.config\">Arquivo de Configurações\r\n\r\n```xml\r\n<connectionStrings>\r\n  <add name=\"DEFAULT\" \r\n\t   connectionString=\"Data Source=INSTANCIA;\r\n\t\t\t\t\tInitial Catalog=dtb_X;\r\n\t\t\t\t\tUser Id=******; \r\n\t\t\t\t\tPassword=*****;\r\n\t\t\t\t\tApp=NomeSistema;\r\n\t\t\t\t\tMultipleActiveResultSets=True;\"    \r\n\t   providerName=\"System.Data.SqlClient\"/>\r\n</connectionStrings>\r\n```\r\n\r\n([Exemplo de chamada da conexão](#conectando))\r\n\r\n##<a id=\"CfConnection\">ConnectionFactory.CfConnection\r\n\r\n### <a id=\"conectando\">Exemplo de conexão com o banco de dados\r\n\r\n```cs\r\nusing (var conn = new CfConnection(\"DEFAULT\"))\r\n{\r\n\t...\r\n}\r\n```\r\n([Exemplo do arquivo de configurações para a conexão \"DEFAULT\"](#web.config))\r\n\r\n\r\n### <a id=\"transactionScope\">Transação com múltiplas conexões (TransactionScope)\r\n\r\nA `TransactionScope`pode ser utilizada em qualquer camada, tanto camada **DAO** com na **BO**\r\n\r\n```cs\r\ntry\r\n{\r\n   // Requer o MSDTC ativo\r\n   using (var scope = new TransactionScope())\r\n   {\r\n   \r\n      //Conexão com banco A no servidor X\r\n      using (var conn = new CfConnection(\"DEFAULT\"))\r\n      {\r\n         ...\r\n      }\r\n      \r\n      //Conexão com o banco B no servidor Y\r\n      using (var conn = new CfConnection(\"PORTAL\"))\r\n      {\r\n         ...\r\n      }\r\n\r\n\t  //Commit em todas as conexões dentro do escopo\r\n      scope.Complete();\r\n   }\r\n   catch (TransactionAbortedException tae)\r\n   {\r\n\t  //Rollback devido erro na transação\r\n\t  ...\r\n   }\r\n   catch (Exception ex)\r\n   {\r\n      //Rollback automatico em todas as conexões dentro do TransactionScope em caso de erros\r\n      ...\r\n   }\r\n}\r\n```\r\n\r\n\r\n### <a id=\"query\">Exemplo de Query retornando entidade carregada\r\n\r\nExecuta a consulta no banco de dados e carrega automaticamente as entidades (VO / DTO), de forma simples, rápida e evitando erros de conversão incorreta.\r\n\r\n```cs\r\nVo.User user;\r\nconst string sql = @\"SELECT * FROM SIS_USER WHERE ID = @Id\";\r\n\r\nusing (var conn = new CfConnection(\"DEFAULT\"))\r\n{\r\n   using (var cmd = conn.CreateCfCommand())\r\n   {\r\n\t  //Listagem de parâmetros\r\n      var param = new List<CfParameter>\r\n      {\r\n         new CfParameter(\"@Id\", id, DbType.Int32)\r\n      };\r\n\r\n\t  //Executa query e retorna DTO carregada\r\n      user = cmd.QueryForObject<Vo.User>\r\n\t\t      (CommandType.Text, sql, param);\r\n   }\r\n}\r\n```   \r\n\r\n##<a id=\"CfCommand\">ConnectionFactory.CfCommand\r\n\r\n\r\n### <a id=\"ExecuteScalar\">ExecuteScalar\r\n\r\nExemplo de um **INSERT** retornando o **ID**.\r\n\r\n```cs\r\nusing (var conn = new CfConnection(\"DEFAULT\"))\r\n{\r\n   using (var cmd = conn.CreateCfCommand())\r\n   {\r\n      var parameters =\r\n         new List<CfParameter>\r\n         {\r\n            new CfParameter(\"@Name\", entity.Name),\r\n            new CfParameter(\"@TimeStamp\", entity.TimeStamp),\r\n            new CfParameter(\"@IsActive\", entity.IsActive),\r\n            new CfParameter(\"@DisplayName\", entity.DisplayName)\r\n         };\r\n\r\n      int id = cmd.ExecuteScalar<int>(CommandType.Text,\r\n         @\"INSERT INTO SIS_PROFILE\r\n\t         (NAME,  UPDATE_TIME, IS_ACTIVE, DISPLAY_NAME)\r\n          VALUES \r\n\t         (@Name, @TimeStamp,  @IsActive, @DisplayName)\r\n           \r\n          SELECT CAST(SCOPE_IDENTITY() AS INT) AS ID\"\r\n         , parameters);\r\n   }\r\n}\r\n```\r\n\r\n\r\n### <a id=\"QueryForObject\">QueryForObject\r\n\r\nExecuta a **Query** ou **Procedure** e retorna uma entidade carregada\r\n\r\n```cs\r\nVo.User user;\r\nconst string sql = @\"SELECT * FROM SIS_USER WHERE ID = @Id\";\r\n\r\nusing (var conn = new CfConnection(\"DEFAULT\"))\r\n{\r\n   using (var cmd = conn.CreateCfCommand())\r\n   {\r\n      var param = new List<CfParameter>\r\n      {\r\n         new CfParameter(\"@Id\", id, DbType.Int32)\r\n      };\r\n\r\n      user = cmd.QueryForObject<Vo.User>(CommandType.Text, sql, param);\r\n   }\r\n}\r\n```\r\n\r\n### <a id=\"QueryForList\">QueryForList\r\n\r\nExecuta uma query ou procedure e retorna uma Lista de entidades.\r\n\r\n```cs\r\nIList<Resource> returnValue = null;\r\n\r\nstring sql = @\"SELECT NAME RESOURCE_NAME\r\n               FROM SIS_RESOURCE\r\n               WHERE ENTITY_NAME=@EntityName\";\r\n\r\nusing (var conn = new CfConnection(\r\n\tUtil.ConnectionNames.DEFAULT.ToString()))\r\n{\r\n    using (var cmd = conn.CreateCfCommand())\r\n\t{\r\n       var param = new List<CfParameter>{\r\n          new CfParameter(\"@EntityName\",entityType)};\r\n\r\n       returnValue = cmd.QueryForList<Resource>\r\n\t       (CommandType.Text,sql,param);\r\n\r\n    }\r\n}\r\n```\r\n\r\n### <a id=\"ExecuteReader\">ExecuteReader\r\n\r\nExecuta uma query ou procedure e retorna um **DataReader**\r\n\r\n```cs\r\nIList<string> returnValue = null;\r\nusing (var conn = new CfConnection(\"DEFAULT\"))\r\n{\r\n\tusing (var cmd = conn.CreateCfCommand())\r\n    {\r\n\t\tconst string sql = \"SELECT NAME FROM SIS_ENTITY\";\r\n\t\tusing (var reader = cmd.ExecuteReader(CommandType.Text, sql))\r\n\t\t{\r\n\t\t\tif (reader.HasRows)\r\n\t\t\t{\r\n\t            returnValue = new List<String>();\r\n\t            while (reader.Read())\r\n\t            {\r\n\t                returnValue.Add(reader[0].ToString());\r\n\t            }\r\n\t        }\r\n\t    }\r\n    }\r\n}\r\n\r\nreturn returnValue;\r\n```\r\n\r\n### <a id=\"ExecuteNonQuery\">ExecuteNonQuery\r\n\r\nExecuta comando SQL sem retorno. Apropriado para INSERT, UPDATE e DELETE\r\n\r\n```cs\r\nvar param =\r\n    new List<CfParameter>\r\n    {\r\n       new CfParameter(\"@Id\", entity.Id),\r\n       new CfParameter(\"@TimeStamp\", entity.TimeStamp),\r\n       new CfParameter(\"@Name\", entity.Name),\r\n       new CfParameter(\"@IsActive\", entity.IsActive),\r\n       new CfParameter(\"@DisplayName\", entity.DisplayName)\r\n    }; \r\n\r\n using (var conn = new CfConnection(\"DEFAULT\"))\r\n {\r\n    using (var cmd = conn.CreateCfCommand())\r\n    {\r\n\t   //Executa comando SQL sem retorno de valor\r\n       cmd.ExecuteNonQuery(CommandType.Text, \r\n          @\"UPDATE SIS_PROFILE\r\n            SET UPDATE_TIME = @TimeStamp, NAME         = @Name, \r\n                IS_ACTIVE   = @IsActive,  DISPLAY_NAME = @DisplayName\r\n            WHERE ID = @Id\", param);\r\n    }\r\n }\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}